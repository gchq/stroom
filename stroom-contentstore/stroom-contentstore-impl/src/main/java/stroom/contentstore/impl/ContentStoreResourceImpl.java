/*
 * Copyright 2016-2025 Crown Copyright
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stroom.contentstore.impl;

import stroom.contentstore.shared.ContentStoreContentPack;
import stroom.contentstore.shared.ContentStoreContentPackWithDynamicState;
import stroom.contentstore.shared.ContentStoreCreateGitRepoRequest;
import stroom.contentstore.shared.ContentStoreResource;
import stroom.contentstore.shared.ContentStoreResponse;
import stroom.contentstore.shared.ContentStoreResponse.Status;
import stroom.contentstore.shared.ContentStoreValueResponse;
import stroom.docref.DocRef;
import stroom.event.logging.rs.api.AutoLogged;
import stroom.explorer.api.ExplorerService;
import stroom.explorer.shared.ExplorerNode;
import stroom.explorer.shared.PermissionInheritance;
import stroom.gitrepo.api.GitRepoStorageService;
import stroom.gitrepo.api.GitRepoStore;
import stroom.gitrepo.shared.GitRepoDoc;
import stroom.util.logging.LambdaLogger;
import stroom.util.logging.LambdaLoggerFactory;
import stroom.util.shared.DocPath;
import stroom.util.shared.Message;
import stroom.util.shared.NullSafe;
import stroom.util.shared.PageRequest;
import stroom.util.shared.ResultPage;
import stroom.util.shared.Severity;
import stroom.util.yaml.YamlUtil;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
import jakarta.inject.Inject;
import jakarta.inject.Provider;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

/**
 * REST server-side implementation for the ContentStore stuff.
 */
@SuppressWarnings("unused")
@AutoLogged
public class ContentStoreResourceImpl implements ContentStoreResource {

    /**
     * Where we get configuration from
     */
    private final Provider<ContentStoreConfig> config;

    /**
     * The store used to create a GitRepo
     */
    private final Provider<GitRepoStore> gitRepoStore;

    /**
     * Provides access to the Explorer Tree
     */
    private final Provider<ExplorerService> explorerService;

    /**
     * Allows this system to automatically pull content
     */
    private final Provider<GitRepoStorageService> gitRepoStorageService;

    /**
     * Allows test code to set a test content store file to use
     */
    private List<String> overrideContentStoreUrls = null;

    /**
     * The size of the buffer used to copy stuff around
     */
    private static final int IO_BUF_SIZE = 4096;

    /**
     * Logger
     */
    private static final LambdaLogger LOGGER = LambdaLoggerFactory.getLogger(ContentStoreResourceImpl.class);

    /**
     * Injected constructor.
     *
     * @param config                Where to get configuration data from.
     * @param gitRepoStore          How to create the GitRepoDoc.
     * @param explorerService       How to interact with the Explorer Tree
     * @param gitRepoStorageService How to pull content from Git
     */
    @SuppressWarnings("unused")
    @Inject
    public ContentStoreResourceImpl(final Provider<ContentStoreConfig> config,
                                    final Provider<GitRepoStore> gitRepoStore,
                                    final Provider<ExplorerService> explorerService,
                                    final Provider<GitRepoStorageService> gitRepoStorageService) {
        this.config = config;
        this.gitRepoStore = gitRepoStore;
        this.explorerService = explorerService;
        this.gitRepoStorageService = gitRepoStorageService;
    }

    /**
     * Method to reset the URLs for use when testing.
     * Ignores the configured or default URLs and adds the given file relative to the given directory.
     * Useful when we want to use a file in the root of the source tree.
     *
     * @param rootDir  The root directory, generated by
     *                 ProjectPathUtil.getRepoRoot().
     * @param filename The name of the file that holds the content store,
     *                 relative to the configFile. Must not be null.
     */
    public synchronized void addTestFileContentStoreUrl(final Path rootDir, final String filename) {
        final URI fileUri = rootDir.resolve(filename).toUri();
        if (overrideContentStoreUrls == null) {
            overrideContentStoreUrls = new ArrayList<>();
        }
        overrideContentStoreUrls.add(fileUri.toString());
    }

    /**
     * Method to reset the URLs for use when testing.
     * Ignores the configured or default URLs and adds the given URL.
     *
     * @param contentStoreUri The URL to add to any other test URLs. Must not be null.
     */
    public synchronized void addTestUriContentStoreUrl(final String contentStoreUri) {
        if (overrideContentStoreUrls == null) {
            overrideContentStoreUrls = new ArrayList<>();
        }
        overrideContentStoreUrls.add(contentStoreUri);
    }

    /**
     * REST method to return the list of content packs to the client.
     *
     * @return A list of content packs. Never returns null but may
     * return an empty list.
     */
    @SuppressWarnings("unused")
    @Override
    public ResultPage<ContentStoreContentPackWithDynamicState> list(final PageRequest pageRequest) {

        // Pull out the existing GitRepos so we know what exists
        final List<DocRef> existingDocRefs = gitRepoStore.get().list();
        final ArrayList<GitRepoDoc> installedGitRepoDocs = new ArrayList<>(existingDocRefs.size());
        for (final DocRef docRef : existingDocRefs) {
            // Not sure if store can return null, but handle it just in case...
            final GitRepoDoc doc = gitRepoStore.get().readDocument(docRef);
            if (doc != null) {
                installedGitRepoDocs.add(doc);
            }
        }

        // Allow tests to override the URLs used for the content store
        final List<String> contentStoreUrls;
        synchronized (this) {
            if (NullSafe.hasItems(overrideContentStoreUrls)) {
                contentStoreUrls = overrideContentStoreUrls;
            } else {
                contentStoreUrls = config.get().getContentStoreUrls();
            }
        }

        // Grab YAML describing the content store
        final ObjectMapper mapper = YamlUtil.getMapper();
        final List<ContentStoreContentPackWithDynamicState> contentPacksWithState = new ArrayList<>();

        for (final String contentStoreUrl : contentStoreUrls) {
            LOGGER.debug("Parsing content store at '{}'", contentStoreUrl);

            try {
                final URI uri = new URI(contentStoreUrl);
                final ContentStore contentStore;
                try (final InputStream inputStream = new BufferedInputStream(uri.toURL().openStream())) {
                    contentStore = mapper.readValue(inputStream, ContentStore.class);
                }
                // Fill in any extra data needed by the content packs
                final List<ContentStoreContentPack> listOfContentPacks = contentStore.getContentPacks();
                for (final ContentStoreContentPack contentPack : listOfContentPacks) {
                    // Store the icon URL for access later
                    LOGGER.debug("ID {} -> URL {}", contentPack.getId(), contentPack.getIconUrl());
                    IconPassthroughServlet.addIdToUrl(contentPack.getId(), contentPack.getIconUrl());

                    // Add the content store metadata
                    contentPack.setContentStoreMetadata(contentStore.getMeta());

                    // Check if content pack is installed or upgradable
                    final ContentStoreContentPackWithDynamicState cpWithState =
                            new ContentStoreContentPackWithDynamicState(contentPack);
                    cpWithState.checkInstallationStatus(installedGitRepoDocs);
                    contentPacksWithState.add(cpWithState);
                }

            } catch (final URISyntaxException | MalformedURLException e) {
                LOGGER.error("Cannot parse App Store URL '{}'.", contentStoreUrl, e);
            } catch (final UnrecognizedPropertyException e) {
                LOGGER.error("Cannot parse App Store URL '{}': {}", contentStoreUrl, e.getMessage(), e);
            } catch (final IOException e) {
                LOGGER.error("Cannot connect to App Store URL '{}'.", contentStoreUrl, e);
            }
        }

        return ResultPage.createPageLimitedList(contentPacksWithState, pageRequest);
    }

    /**
     * Checks to see if a GitRepo exists that matches the content pack.
     * Not a full check to see if there is a match; just compare
     * content store owner ID and content pack ID.
     *
     * @param contentPack The content pack to check for a match.
     * @return true if the GitRepo already exists; false if not.
     */
    @Override
    public boolean exists(final ContentStoreContentPack contentPack) {
        final List<DocRef> existingDocRefs = gitRepoStore.get().list();
        for (final DocRef existingDocRef : existingDocRefs) {
            final GitRepoDoc existingGitRepoDoc = gitRepoStore.get().readDocument(existingDocRef);
            if (contentPack.matches(existingGitRepoDoc)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Creates a GitRepoDoc from a Content Pack.
     *
     * @param createGitRepoRequest The request holding the content pack
     *                             that holds the data for the GitRepoDoc.
     */
    @Override
    public ContentStoreResponse create(final ContentStoreCreateGitRepoRequest createGitRepoRequest) {
        LOGGER.debug("REST request to create GitRepo from Content Store: {}", createGitRepoRequest);
        boolean isMockEnvironment = false;

        // Return value
        ContentStoreResponse response;

        final List<Message> messages = new ArrayList<>();

        final ContentStoreContentPack contentPack = createGitRepoRequest.getContentPack();
        if (this.exists(contentPack)) {
            LOGGER.error("Content pack already exists within Stroom");
            response = new ContentStoreResponse(ContentStoreResponse.Status.ALREADY_EXISTS,
                    "Content pack already exists");
        } else {
            try {
                // Put the document into the Explorer Tree
                LOGGER.debug("Creating DocPath from '{}'", contentPack.getStroomPath());
                final DocPath docPathToGitRepo = DocPath.fromPathString(contentPack.getStroomPath());
                final ExplorerNode parentNode = explorerService.get().ensureFolderPath(docPathToGitRepo,
                        PermissionInheritance.DESTINATION);
                final ExplorerNode gitRepoNode = explorerService.get().create(
                        GitRepoDoc.TYPE,
                        contentPack.getGitRepoName(),
                        parentNode,
                        PermissionInheritance.DESTINATION);

                final DocRef docRef;
                if (gitRepoNode == null) {
                    LOGGER.warn("In a Mock environment? No explorer node; creating GitRepo directly.");
                    isMockEnvironment = true;
                    docRef = gitRepoStore.get().createDocument(
                            createGitRepoRequest.getContentPack().getGitRepoName());
                } else {
                    // Update the GitRepoDoc
                    docRef = gitRepoNode.getDocRef();
                }
                final GitRepoDoc gitRepoDoc = gitRepoStore.get().readDocument(docRef);
                contentPack.updateSettingsIn(gitRepoDoc);

                // Add credentials if necessary
                if (contentPack.getGitNeedsAuth()) {
                    messages.add(new Message(Severity.INFO, "Adding credentials for pull"));
                    gitRepoDoc.setCredentialName(createGitRepoRequest.getCredentialName());
                }

                // Write doc to DB
                gitRepoStore.get().writeDocument(gitRepoDoc);

                // Do the pull
                final List<Message> pullMessages = gitRepoStorageService.get().importDoc(
                        gitRepoDoc,
                        isMockEnvironment);
                messages.addAll(pullMessages);

                // Tell the user it worked
                response = this.createOkResponse("Created", contentPack, messages);

            } catch (final IOException e) {
                response = this.createErrResponse(
                        "Error pulling files from Content Pack: " + e.getMessage(),
                        messages,
                        e);
            } catch (final RuntimeException e) {
                response = this.createErrResponse(
                        "Error creating Content Pack: " + e.getMessage(),
                        messages,
                        e);
            }
        }

        return response;
    }

    /**
     * Creates the response to send back to the client if everything went ok.
     *
     * @param operation   String describing what we've done - Created, Upgraded etc.
     * @param contentPack The content pack we were trying to import.
     * @param messages    The list of messages to send back.
     * @return The response to send back. Never null.
     */
    private ContentStoreResponse createOkResponse(
            final String operation,
            final ContentStoreContentPack contentPack,
            final List<Message> messages) {

        final StringBuilder buf = new StringBuilder(operation);
        buf.append(" '");
        buf.append(contentPack.getUiName());
        buf.append("'\n");
        for (final Message m : messages) {
            buf.append('\n');
            buf.append(m);
        }

        LOGGER.debug("{} Content Pack: \n{}", operation, buf);
        return new ContentStoreResponse(ContentStoreResponse.Status.OK, buf.toString());
    }

    /**
     * Returns the response if something goes wrong.
     *
     * @param errorMessage The error message to send back.
     * @param messages     List of messages. Can be null or empty.
     * @param cause        The exception, if any. Can be null.
     * @return The response. Never null.
     */
    private ContentStoreResponse createErrResponse(
            final String errorMessage,
            final List<Message> messages,
            final Exception cause) {

        final StringBuilder buf = new StringBuilder(errorMessage);
        if (cause != null) {
            buf.append("\n    ");
            buf.append(cause.getMessage());
        }
        if (messages != null && !messages.isEmpty()) {
            buf.append("\n\nAdditional information:");
            for (final Message m : messages) {
                buf.append("\n    ");
                buf.append(m);
            }
        }

        LOGGER.error("Error creating Content Pack: \n{}",
                buf,
                cause);

        return new ContentStoreResponse(Status.GENERAL_ERR, buf.toString());
    }

    @Override
    public ContentStoreValueResponse<Boolean> checkContentUpgradeAvailable(final ContentStoreContentPack contentPack) {
        LOGGER.debug("Checking for upgrades for {}", contentPack.getUiName());

        try {
            // Find a matching GitRepoDoc
            GitRepoDoc gitRepoDoc = null;
            final List<DocRef> existingDocRefs = gitRepoStore.get().list();
            for (final DocRef existingDocRef : existingDocRefs) {
                final GitRepoDoc existingGitRepoDoc = gitRepoStore.get().readDocument(existingDocRef);
                if (contentPack.matches(existingGitRepoDoc)) {
                    gitRepoDoc = existingGitRepoDoc;
                    break;
                }
            }

            // Check if updates are available for this doc
            Boolean retval = Boolean.FALSE;
            if (gitRepoDoc != null) {
                retval = gitRepoStorageService.get().areUpdatesAvailable(null, gitRepoDoc);
            }

            return new ContentStoreValueResponse<>(
                    true,
                    retval,
                    null);

        } catch (final IOException e) {

            final StringBuilder buf =
                    new StringBuilder("Error checking whether the content pack \"");
            buf.append(contentPack.getUiName());
            buf.append("\" can be upgraded:\n    ");
            buf.append(e.getMessage());

            LOGGER.error("{}",
                    buf,
                    e);

            return new ContentStoreValueResponse<>(false,
                    null,
                    buf.toString());
        }
    }

    @Override
    public ContentStoreResponse upgradeContentPack(final ContentStoreContentPack contentPack) {
        LOGGER.debug("Upgrading {}", contentPack.getUiName());
        final ArrayList<Message> messages = new ArrayList<>();
        try {
            // Find a matching GitRepoDoc
            GitRepoDoc gitRepoDoc = null;
            final List<DocRef> existingDocRefs = gitRepoStore.get().list();
            for (final DocRef existingDocRef : existingDocRefs) {
                final GitRepoDoc existingGitRepoDoc = gitRepoStore.get().readDocument(existingDocRef);
                if (contentPack.matches(existingGitRepoDoc)) {
                    gitRepoDoc = existingGitRepoDoc;
                    break;
                }
            }

            if (gitRepoDoc == null) {
                throw new IOException("Cannot upgrade Content Pack as it is not installed");
            }

            // Do a pack upgrade
            // i.e. copy settings from Content Pack into GitRepo
            contentPack.updateSettingsIn(gitRepoDoc);

            // Pull down any new content
            messages.addAll(this.gitRepoStorageService.get().importDoc(gitRepoDoc, false));

            return createOkResponse("Upgraded", contentPack, messages);

        } catch (final IOException e) {
            return this.createErrResponse("Error upgrading content pack",
                    messages,
                    e);
        }

    }

}

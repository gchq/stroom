/*
 * Copyright 2016-2025 Crown Copyright
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stroom.db.migration;

import stroom.util.ColouredStringBuilder;
import stroom.util.ConsoleColour;
import stroom.util.logging.LogUtil;
import stroom.util.shared.Version;

import com.google.common.base.Strings;
import jakarta.validation.constraints.NotNull;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Isolated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Disabled // Manual running only as it is just listing stuff, not really a test
@Isolated // This is walking the file tree so doesn't like it if another test is mutating
// the file tree at the same time.
public class TestListDbMigrations {

    private static final Logger LOGGER = LoggerFactory.getLogger(TestListDbMigrations.class);

    // Have to cope with stroom mig files, e.g. 07_00_00_017__IDX_SHRD.sql
    // and auth mig files, e.g. V2_1__Create_tables.sql
    private static final Pattern MIGRATION_FILE_REGEX_PATTERN = Pattern.compile(
            "^V([0-9]{1,2}_){2}[0-9]{1,2}(_[0-9]+)?__.*\\.(sql|java)$");
    private static final Pattern MIGRATION_FILE_PREFIX_REGEX_PATTERN = Pattern.compile(
            "^V([0-9]{1,2})_([0-9]{1,2})_([0-9]{1,2})");
    private static final Pattern MIGRATION_PATH_REGEX_PATTERN = Pattern.compile("^.*/src/main/.*$");

    Map<String, List<Script>> moduleToScriptMap = new HashMap<>();
    private int maxFileNameLength;

    @Test
    void listDbMigrationsForLatestVersion() throws Exception {
        populateMigrationsMap();

        final Map<Version, Map<String, List<Script>>> verNestedMap = moduleToScriptMap.values()
                .stream()
                .flatMap(List::stream)
                .collect(Collectors.groupingBy(Script::getVersion, Collectors.groupingBy(Script::moduleName)));

        final Version latestVersion = verNestedMap.keySet()
                .stream()
                .max(Comparator.naturalOrder())
                .orElseThrow(() -> new RuntimeException("Should have at least one ver in here"));


        final Map<String, List<Script>> moduleToSingleVerScriptsMap = verNestedMap.get(latestVersion);

        if (moduleToSingleVerScriptsMap.isEmpty()) {
            System.out.println("No migrations scripts for version: " + latestVersion);
        } else {
            System.out.println("Showing migration scripts for version: " + latestVersion);
            System.out.println("--------------------------------------------------------------------------------");
            final Comparator<String> moduleComparator = buildModuleNameComparator();
            final StringBuilder sb = new StringBuilder();
            sb.append(LogUtil.message("""
                    ### Migration Scripts
                    \s
                    <!--
                    #############################################################################################
                    #                                                                                           #
                    #  This section is auto-generated by TestListDbMigrations.listDbMigrationsForLatestVersion  #
                    #                                                                                           #
                    #############################################################################################
                    -->
                    \s
                    For information purposes only, the following are the database migrations that will be run \
                    when upgrading to {} from the previous minor version.
                    \s
                    Note, the `legacy` module will run first (if present) then the other module will run in no \
                    particular order.""", latestVersion));

            moduleToSingleVerScriptsMap.entrySet()
                    .stream()
                    .sorted(Comparator.comparing(Entry::getKey, moduleComparator))
                    .filter(entry -> !entry.getValue().isEmpty())
                    .forEach(entry -> {
                        final String module = entry.getKey();
                        final List<Script> scripts = entry.getValue();

                        sb.append(LogUtil.message("""
                                \s
                                \s
                                #### Module `{}`""", module));

                        scripts.forEach(script -> {
                            if (script.fileName.endsWith(".sql")) {
                                appendSqlMig(latestVersion, script, sb);
                            } else {
                                appendOtherMig(latestVersion, script, sb);
                            }

                        });

                    });

            System.out.println(sb);
        }
    }

    private void appendSqlMig(final Version version, final Script script, final StringBuilder sb) {

        final String fileContent;
        try {
            fileContent = Files.readString(script.absLocalPath);
        } catch (final IOException e) {
            throw new RuntimeException(LogUtil.message(
                    "Unable to read migration script {}: {}",
                    script.relPath.toAbsolutePath().normalize(),
                    LogUtil.exceptionMessage(e)), e);
        }

        final String template = """
                \s
                \s
                ##### Script `{}`
                \s
                **Path**: `{}`
                \s
                ```sql
                {}
                ```
                """;
        sb.append(LogUtil.message(
                template,
                script.fileName,
                script.relPath.toString(),
                fileContent));
    }

    private void appendOtherMig(final Version version, final Script script, final StringBuilder sb) {
        final String branch = version.getMajor() + "." + version.getMinor();
        final String githubUrl = "https://github.com/gchq/stroom/tree/" + branch + "/" + script.relPath.toString();
        final String template = """
                \s
                \s
                ##### Script `{}`
                \s
                **Path**: `{}`
                \s
                It is not possible to display the content here.
                The file can be viewed on : {{< external-link "GitHub" "{}" >}}""";
        sb.append(LogUtil.message(
                template,
                script.fileName,
                script.relPath.toString(),
                githubUrl));
    }

    @Test
    void listDbMigrationsByVersion() throws IOException {
        populateMigrationsMap();

        final Map<Version, Map<String, List<Script>>> map = moduleToScriptMap.values()
                .stream()
                .flatMap(List::stream)
                .collect(Collectors.groupingBy(Script::getVersion, Collectors.groupingBy(Script::moduleName)));

        final ColouredStringBuilder stringBuilder = new ColouredStringBuilder();
        final Comparator<String> moduleComparator = buildModuleNameComparator();
        final Comparator<String> filenameComparator = buildFileNameComparator();

        map.entrySet()
                .stream()
                .sorted(Comparator.comparing(Entry::getKey))
                .forEach(entry -> {
                    final Version version = entry.getKey();
                    final Map<String, List<Script>> prefixToScriptsMap = entry.getValue();
                    stringBuilder.appendMagenta(version.toString())
                            .append("\n");
                    prefixToScriptsMap.entrySet()
                            .stream()
                            .sorted(Comparator.comparing(Entry::getKey, moduleComparator))
                            .forEach(entry2 -> {
                                final String moduleName = entry2.getKey();
                                final List<Script> scripts = entry2.getValue();
                                if (!scripts.isEmpty()) {
                                    stringBuilder
                                            .append("  ")
                                            .appendMagenta(moduleName)
                                            .append("\n");
                                    scripts.forEach(script -> {
                                        appendScript(stringBuilder, script, "    ");
                                    });
                                }
                            });
                });
        System.out.println(stringBuilder.toString());
    }

    /**
     * Finds all the v7 DB migration scripts and dumps them out in order.
     * Useful for seeing the sql and java migrations together
     */
    @Test
    void listDbMigrationsByModule() throws IOException {

        populateMigrationsMap();

        final ColouredStringBuilder stringBuilder = new ColouredStringBuilder();

        final Comparator<String> moduleComparator = buildModuleNameComparator();

        moduleToScriptMap.entrySet().stream()
                .sorted(Map.Entry.comparingByKey(moduleComparator))
                .forEach(entry -> {
                    stringBuilder
                            .appendMagenta(entry.getKey())
                            .append("\n");
                    entry.getValue()
                            .forEach(script -> {
                                appendScript(stringBuilder, script, "  ");
                            });
                    stringBuilder.append("\n");
                });
//        LOGGER.info("\n{}", stringBuilder.toString());
        System.out.println(stringBuilder.toString());
    }

    private void appendScript(final ColouredStringBuilder stringBuilder,
                              final Script script,
                              final String padding) {
        final String filename = script.fileName();
        stringBuilder.append(padding);

        final ConsoleColour colour;
        if (filename.endsWith(".sql")) {
            colour = ConsoleColour.YELLOW;
        } else if (filename.endsWith(".java")) {
            colour = ConsoleColour.BLUE;
        } else {
            colour = ConsoleColour.RED;
        }
        stringBuilder
                .append(Strings.padEnd(filename, maxFileNameLength, ' '), colour)
                .append(" - ")
                .append(script.relPath().toString(), colour)
                .append("\n");
    }

    private static Comparator<String> buildModuleNameComparator() {
        // Core is always run first so list it first
        final Comparator<String> moduleComparator = (o1, o2) -> {
            final String stroomCoreModuleName = "stroom-core";

            if (Objects.equals(o1, o2)) {
                return 0;
            } else if (stroomCoreModuleName.equals(o1)) {
                return -1;
            } else if (stroomCoreModuleName.equals(o2)) {
                return 1;
            } else {
                return Comparator.<String>naturalOrder().compare(o1, o2);
            }
        };
        return moduleComparator;
    }

    private void populateMigrationsMap() throws IOException {
        if (moduleToScriptMap.isEmpty()) {
            final Path projectRoot = Paths.get("../").toAbsolutePath().normalize();

            try (final Stream<Path> stream = Files.list(projectRoot)) {
                stream
                        .filter(Files::isDirectory)
                        .filter(path -> path.getFileName().toString().startsWith("stroom-"))
                        .sorted()
                        .forEach(this::inspectModule);
            }

            maxFileNameLength = moduleToScriptMap.values().stream()
                    .flatMap(value -> value.stream()
                            .map(Script::fileName))
                    .mapToInt(String::length)
                    .max()
                    .orElse(60);
        }
    }

    private void inspectModule(final Path moduleDir) {

        // Core is always run first so list it first
        final Comparator<String> fileNameComparator = buildFileNameComparator();
        final String moduleName = moduleDir.getFileName().toString();

        Path projectRootDir = moduleDir;
        while (!Files.exists(projectRootDir.resolve(".git"))) {
            projectRootDir = projectRootDir.resolve("..")
                    .toAbsolutePath()
                    .normalize();
        }
        final Path projectRootDirFinal = projectRootDir;

        final List<Path> migrationFiles = new ArrayList<>();

        // For some reason when we used Files.walk() it would fail with a NoSuchFileException
        // on an .attach_pid file, so have to do this.
        try {
            Files.walkFileTree(moduleDir, new FileVisitor<>() {
                @Override
                public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs) {
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) {
                    if (Files.isRegularFile(file)
                        && MIGRATION_PATH_REGEX_PATTERN.matcher(file.toString()).matches()
                        && MIGRATION_FILE_REGEX_PATTERN.matcher(file.getFileName().toString()).matches()) {
                        migrationFiles.add(file);
                    } else {
                        LOGGER.debug("No match {}", file);
                    }
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFileFailed(final Path file, final IOException exc) {
                    LOGGER.warn("Error visiting file {}", file, exc);
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) {
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }

        migrationFiles.stream()
                .map(path ->
                        new Script(
                                moduleName,
                                path.getFileName().toString(),
                                projectRootDirFinal.relativize(path),
                                path.toAbsolutePath().normalize()))
                .filter(script ->
                        MIGRATION_FILE_REGEX_PATTERN.asMatchPredicate().test(script.fileName()))
                .sorted(Comparator.comparing(Script::fileName, fileNameComparator))
                .forEach(tuple -> {
                    moduleToScriptMap.computeIfAbsent(moduleName, k -> new ArrayList<>())
                            .add(tuple);
                });
    }

    @NotNull
    private Comparator<String> buildFileNameComparator() {
        return (name1, name2) -> {

            final Pattern authMigrationPattern = Pattern.compile("^V[0-9]_.*");

            String name1Modified = name1;
            String name2Modified = name2;

            LOGGER.trace("[{}] [{}]", name1Modified, name2Modified);

            // Special case for auth as the filenames have a different format
            // so we need to strip the non numeric parts off then sort numerically
            if (authMigrationPattern.matcher(name1Modified).matches()) {
                name1Modified = name1Modified.replaceFirst("^V", "V0");
            }
            if (authMigrationPattern.matcher(name2Modified).matches()) {
                name2Modified = name2Modified.replaceFirst("^V", "V0");
            }

            return Comparator.<String>naturalOrder().compare(name1Modified, name2Modified);
        };
    }


    // --------------------------------------------------------------------------------


    private record Script(String moduleName,
                          String fileName,
                          Path relPath,
                          Path absLocalPath) {

        String getVersionPrefix() {
            try {
                final Matcher matcher = MIGRATION_FILE_PREFIX_REGEX_PATTERN.matcher(fileName);
                if (matcher.find()) {
                    return matcher.group();
                } else {
                    throw new RuntimeException("Prefix not found for '" + fileName + "'");
                }
            } catch (final IllegalStateException e) {
                throw new RuntimeException("Prefix not found for '" + fileName + "': " + e.getMessage());
            }
        }

        Version getVersion() {
            try {
                final Matcher matcher = MIGRATION_FILE_PREFIX_REGEX_PATTERN.matcher(fileName);
                if (matcher.find()) {
                    return new Version(
                            Integer.parseInt(matcher.group(1)),
                            Integer.parseInt(matcher.group(2)),
                            Integer.parseInt(matcher.group(3)));
                } else {
                    throw new RuntimeException("Prefix not found for '" + fileName + "'");
                }
            } catch (final IllegalStateException e) {
                throw new RuntimeException("Prefix not found for '" + fileName + "': " + e.getMessage());
            }
        }
    }

    private boolean isNotAttachePidFile(final Path path) {
        if (path.getFileName().toString().startsWith(".attach_pid")) {
            LOGGER.info("Ignoring: {}", path);
            return false;
        } else {
            return true;
        }
    }
}
